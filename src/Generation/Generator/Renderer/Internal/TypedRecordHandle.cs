using System;
using System.Linq;
using System.Text;
using Generator.Model;
using Generator.Renderer.Internal.Field;

namespace Generator.Renderer.Internal;

internal static class TypedRecordHandle
{
    public static string Render(GirModel.Record record)
    {
        var typeName = Model.TypedRecord.GetInternalHandle(record);
        var dataName = Model.TypedRecord.GetDataName(record);
        var unownedHandleTypeName = Model.TypedRecord.GetInternalUnownedHandle(record);
        var mangedHandleTypeName = Model.TypedRecord.GetInternalManagedHandle(record);
        var ownedHandleTypeName = Model.TypedRecord.GetInternalOwnedHandle(record);
        var arrayHandleType = Model.TypedRecord.GetInternalArrayHandle(record);
        var arrayUnownedHandleTypeName = Model.TypedRecord.GetInternalArrayUnownedHandle(record);
        var arrayOwnedHandleTypeName = Model.TypedRecord.GetInternalArrayOwnedHandle(record);
        var fullyQualifiedType = $"{Model.TypedRecord.GetFullyQualifiedPublicClassName(record)}";
        var getGType = $"{Model.TypedRecord.GetFullyQualifiedInternalClassName(record)}.{Function.GetGType}()";

        return $@"using System;
using GObject;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace {Namespace.GetInternalName(record.Namespace)};

// AUTOGENERATED FILE - DO NOT MODIFY

{PlatformSupportAttribute.Render(record as GirModel.PlatformDependent)}
public abstract class {typeName} : SafeHandle, IEquatable<{typeName}>
{{    
    public sealed override bool IsInvalid => handle == IntPtr.Zero;

    protected {typeName}(bool ownsHandle) : base(IntPtr.Zero, ownsHandle) {{ }}

    {RenderCopyFunction(record)}

    public {ownedHandleTypeName} OwnedCopy()
    {{
        {RenderCopyStatement(record, "ptr", "handle")}
        return new {ownedHandleTypeName}(ptr);
    }}
    
    public {unownedHandleTypeName} UnownedCopy()
    {{
        {RenderCopyStatement(record, "ptr", "handle")}
        return new {unownedHandleTypeName}(ptr);
    }}

    {record.Fields.Select(x => RenderField(record, x)).Join(Environment.NewLine)}

    public bool Equals({typeName}? other)
    {{
        if (ReferenceEquals(null, other))
            return false;

        if (ReferenceEquals(this, other))
            return true;

        return handle.Equals(other.handle);
    }}

    public override bool Equals(object? obj)
    {{
        return ReferenceEquals(this, obj) || obj is {typeName} other && Equals(other);
    }}

    public override int GetHashCode()
    {{
        return handle.GetHashCode();
    }}
}}

public class {unownedHandleTypeName} : {typeName}
{{
    private static {unownedHandleTypeName}? nullHandle;
    public static {unownedHandleTypeName} NullHandle => nullHandle ??= new {unownedHandleTypeName}();

    /// <summary>
    /// Creates a new instance of {unownedHandleTypeName}. Used automatically by PInvoke.
    /// </summary>
    internal {unownedHandleTypeName}() : base(false) {{ }}

    /// <summary>
    /// Creates a new instance of {ownedHandleTypeName}. Assumes that the given pointer is unowned by the runtime.
    /// </summary>
    public {unownedHandleTypeName}(IntPtr ptr) : base(false)
    {{
        SetHandle(ptr);
    }}

    protected override bool ReleaseHandle()
    {{
        throw new System.Exception(""UnownedHandle must not be freed"");
    }}
}}

public partial class {ownedHandleTypeName} : {typeName}
{{
    /// <summary>
    /// Creates a new instance of {ownedHandleTypeName}. Used automatically by PInvoke.
    /// </summary>
    internal {ownedHandleTypeName}() : base(true) {{ }}

    /// <summary>
    /// Creates a new instance of {ownedHandleTypeName}. Assumes that the given pointer is owned by the runtime.
    /// </summary>
    public {ownedHandleTypeName}(IntPtr ptr) : base(true)
    {{
        SetHandle(ptr);
    }}

    {RenderFreeFunction(record)}

    /// <summary>
    /// Create a {ownedHandleTypeName} from a pointer that is assumed unowned. To do so a
    /// boxed copy is created of the given pointer to be used as the handle.
    /// </summary>
    /// <param name=""ptr"">A pointer to a {record.Name} which is not owned by the runtime.</param>
    /// <returns>A {ownedHandleTypeName}</returns>
    public static {ownedHandleTypeName} FromUnowned(IntPtr ptr)
    {{
        {RenderCopyStatement(record, "ownedPtr", "ptr")}
        return new {ownedHandleTypeName}(ownedPtr);
    }}

    partial void OnReleaseHandle();

    protected override bool ReleaseHandle()
    {{
        OnReleaseHandle();
        {RenderFreeStatement(record, "handle")}
        return true;
    }}
}}

public class {mangedHandleTypeName} : {ownedHandleTypeName}
{{
    private {mangedHandleTypeName}(IntPtr handle) : base(handle) 
    {{
    }}

    public static {mangedHandleTypeName} Create()
    {{
        var size = Marshal.SizeOf<{dataName}>();
        var ptr = GLib.Functions.Malloc((nuint)size);
       
        var str = new {dataName}();
        Marshal.StructureToPtr(str, ptr, false);
            
        return new {mangedHandleTypeName}(ptr);
    }}

    protected override bool ReleaseHandle()
    {{
        GObject.Internal.Functions.BoxedFree({getGType}, handle);
        return true;
    }}
}}

public abstract class {arrayHandleType} : SafeHandle
{{
    public sealed override bool IsInvalid => handle == IntPtr.Zero;

    protected {arrayHandleType}(bool ownsHandle) : base(IntPtr.Zero, ownsHandle) {{ }}
}}

public class {arrayUnownedHandleTypeName} : {arrayHandleType}
{{
    private static {arrayUnownedHandleTypeName}? nullHandle;
    public static {arrayUnownedHandleTypeName} NullHandle => nullHandle ??= new {arrayUnownedHandleTypeName}();
    
    private int length;

    /// <summary>
    /// Creates a new instance of {arrayUnownedHandleTypeName}. Used automatically by PInvoke.
    /// </summary>
    internal {arrayUnownedHandleTypeName}() : base(false) {{ }}
    
    public {arrayUnownedHandleTypeName}(IntPtr ptr, int length) : base(false)
    {{
        this.length = length;
        SetHandle(ptr);
    }}

    public {fullyQualifiedType}[] ToArray(int length)
    {{
        return ToNullableArray(length) ?? throw new InvalidOperationException(""Handle is invalid"");
    }}

    public {fullyQualifiedType}[]? ToNullableArray(int length)
    {{
        if (IsInvalid)
            return null;
        
        var data = new {fullyQualifiedType}[length];
        var currentHandle = handle;
        for(int i = 0; i < length; i++)
        {{
            var ownedHandle = new {Model.TypedRecord.GetFullyQuallifiedUnownedHandle(record)}(currentHandle).OwnedCopy();
            data[i] = new {fullyQualifiedType}(ownedHandle);
            currentHandle += Marshal.SizeOf<{Model.TypedRecord.GetFullyQuallifiedDataName(record)}>();
        }}

        return data;
    }}

    protected override bool ReleaseHandle()
    {{
        throw new System.Exception(""UnownedHandle must not be freed"");
    }}
}}

public class {arrayOwnedHandleTypeName} : {arrayHandleType}
{{
    
    //This has no constructor without parameters as we can't supply a length to an array via pinvoke.
    //The length would need to be set manually and the instance be freed via glib.

    private {arrayOwnedHandleTypeName}(IntPtr ptr) : base(true)
    {{
        SetHandle(ptr);
    }}

    public static {arrayOwnedHandleTypeName} Create({Model.TypedRecord.GetFullyQualifiedPublicClassName(record)}[] data)
    {{
        var size = Marshal.SizeOf<{Model.TypedRecord.GetFullyQuallifiedDataName(record)}>();
        var ptr = Marshal.AllocHGlobal(size * data.Length);
        var current = ptr;
        for (int i = 0; i < data.Length; i++)
        {{
            Marshal.StructureToPtr(data[i], current, false);
            current += size;
        }}
        
        return new {arrayOwnedHandleTypeName}(ptr);
    }}
    
    protected override bool ReleaseHandle()
    {{
        Marshal.FreeHGlobal(handle);
        return true;
    }}
}}";
    }

    private static string RenderField(GirModel.Record record, GirModel.Field field)
    {
        var renderableField = Fields.GetRenderableField(field);

        if (field is { IsReadable: false, IsWritable: false } || field.IsPrivate)
            return string.Empty;

        var result = new StringBuilder();

        if (field.IsReadable)
            result.AppendLine(RenderFieldGetter(record, field, renderableField));

        if (field.IsWritable)
            result.AppendLine(RenderFieldSetter(record, field, renderableField));

        return result.ToString();

    }

    private static string RenderFieldGetter(GirModel.Record record, GirModel.Field field, RenderableField renderableField)
    {
        var typePrefix = field.AnyTypeOrCallback.IsT1 ? $"{Model.TypedRecord.GetDataName(record)}." : string.Empty;
        var dataName = Model.TypedRecord.GetDataName(record);

        return @$"public unsafe {typePrefix}{renderableField.NullableTypeName} Get{renderableField.Name}()
{{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException(""Handle is closed or invalid"");

    return Marshal.PtrToStructure<{dataName}>(handle).{renderableField.Name};
}}";
    }

    private static string RenderFieldSetter(GirModel.Record record, GirModel.Field field, RenderableField renderableField)
    {
        var dataName = Model.TypedRecord.GetDataName(record);

        return @$"public unsafe void Set{renderableField.Name}({renderableField.NullableTypeName} value)
{{
    if (IsClosed || IsInvalid)
        throw new InvalidOperationException(""Handle is closed or invalid"");

    var data = Marshal.PtrToStructure<{dataName}>(handle);
    data.{renderableField.Name} = value;
    Marshal.StructureToPtr(data, handle, false);
}}";
    }

    private static string RenderCopyFunction(GirModel.Record record)
    {
        return record.CopyFunction is null || !Method.IsValidCopyFunction(record.CopyFunction)
            ? string.Empty
            : $"""
                  [DllImport(ImportResolver.Library, EntryPoint = "{record.CopyFunction}")]
                  protected static extern IntPtr Copy(IntPtr handle);
               """;
    }

    private static string RenderFreeFunction(GirModel.Record record)
    {
        return record.FreeFunction is null || !Method.IsValidFreeFunction(record.FreeFunction)
            ? string.Empty
            : $"""
                   [DllImport(ImportResolver.Library, EntryPoint = "{record.FreeFunction}")]
                   private static extern void Free(IntPtr handle);
               """;
    }

    private static string RenderCopyStatement(GirModel.Record record, string resultVariable, string parameterVariable)
    {
        var getGType = $"{Model.OpaqueTypedRecord.GetFullyQualifiedInternalClassName(record)}.{Function.GetGType}()";

        return record.CopyFunction is null || !Method.IsValidCopyFunction(record.CopyFunction)
            ? $"var {resultVariable} = GObject.Internal.Functions.BoxedCopy({getGType}, {parameterVariable});"
            : $"var {resultVariable} = Copy({parameterVariable});";
    }

    private static string RenderFreeStatement(GirModel.Record record, string parameterVariable)
    {
        var getGType = $"{Model.OpaqueTypedRecord.GetFullyQualifiedInternalClassName(record)}.{Function.GetGType}()";

        return record.FreeFunction is null || !Method.IsValidFreeFunction(record.FreeFunction)
            ? $"GObject.Internal.Functions.BoxedFree({getGType}, {parameterVariable});"
            : $"Free({parameterVariable});";
    }

}
